module Bool (evalBoolExpression) where

------------------------------------------------- <Imports> ------------------------------------------------------

import Parser.ParserTypes(BoolExpr(..))
import Control.Monad.State

--import Strings
import ProgrammState
import Expressions

------------------------------------------------- </Imports> -----------------------------------------------------



-- This function evaluates boolen expressions, which means...
--   -> Comparison of 2 numerical expressions
--   -> Comparison of 2 string expressions
--   -> Adjunction of 2 boolean values with logical operators
--
-- Now in state monad cause it reads maybe variables and can also change the state.

evalBoolExpression :: BoolExpr -> PState Bool
evalBoolExpression (BoolExprNum (numExpr1,numExpr2) strOp) = do
    val1 <- evalExpression numExpr1
    val2 <- evalExpression numExpr2
    return $ evalBoolFunc strOp val1 val2

evalBoolExpression (BoolExprString (strExpr1,strExpr2) strOp) = do
    val1 <- evalStringExpression strExpr1
    val2 <- evalStringExpression strExpr2 
    return $ evalBoolFunc strOp val1 val2
 
evalBoolExpression (BoolExprLog (boolExpr1,boolExpr2) strOp) = do
    val1 <- evalBoolExpression boolExpr1 
    val2 <- evalBoolExpression boolExpr2 
    return $ evalBoolLogic strOp val1 val2



evalLogicExpression :: String -> Float -> Float -> Int 
evalLogicExpression "||" op1 op2 = 
    let bin1   = toBin $ truncate op1
        bin2   = toBin $ truncate op2
        maxlen = max (length bin1) (length bin2)
        bin1'  = fillBinToSize bin1 maxlen
        bin2'  = fillBinToSize bin2 maxlen
    in  toIntFromBin $ combine2Lists bin1' bin2' binaryOr
evalLogicExpression "&&" op1 op2 = 
    let bin1   = toBin $ truncate op1
        bin2   = toBin $ truncate op2
        maxlen = max (length bin1) (length bin2)
        bin1'  = fillBinToSize bin1 maxlen
        bin2'  = fillBinToSize bin2 maxlen
    in  toIntFromBin $ combine2Lists bin1' bin2' binaryAnd
evalLogicExpression "not" op1 = 
    let bin1   = toBin $ truncate op1
    in  toIntFromBin $ map binaryNot bin1
evalLogicExpression _ = error "unallowed logic op"


fillBinToSize :: [Int] -> Int -> [Int]
fillBinToSize bin size
    | length bin < size = (take (size - (length bin)) $ repeat 0) ++ bin
    | length bin == size = bin
    | otherwise = error "binary numbers not same size!"


-- TODO: fold alarm !!!
toIntFromBin :: [Int] -> Int
toIntFromBin bin = toIntFromBin' bin ((length bin) - 1)
  where
        toIntFromBin' []     -1  = 0
        toIntFromBin' (x:xs) exp = x * 2 ^ exp + toIntFromBin' xs (exp - 1)
        toIntFromBin' _      _   = error "Error by concerting from bin to int!"


toBin :: Int -> [Int]
toBin = reverse $ toBin' 
  where
        toBin' :: Int -> [Int]
        toBin' x = (mod x 2) : (toBin' $ div x 2)


binaryOr :: Int -> Int -> Int
binaryOr 0 0 = 0
binaryOr 0 1 = 1
binaryOr 1 0 = 1
binaryOr 1 1 = 1
binaryOr _ _ = error "non binary value"


binaryAnd :: Int -> Int -> Int
binaryAnd 0 0 = 0
binaryAnd 0 1 = 0
binaryAnd 1 0 = 0
binaryAnd 1 1 = 1
binaryAnd _ _ = error "non binary value"

binaryNot :: Int -> Int
binaryNot 0 = 1
binaryNot 1 = 0
binaryNot _ _ = error "non binary value"


combine2Lists :: [a] -> [b] -> (a -> b -> c) -> [c]
combine2Lists []     []     _ = []
combine2Lists (x:xs) (y:ys) f = (f x y) : combine2Lists xs ys f
combine2Lists _      _      _ = error "Combine2lists awaits lists of same length!"

evalBoolLogic :: String -> Bool -> Bool -> Bool
evalBoolLogic str arg1 arg2
    | str == "||" = arg1 || arg2
    | str == "&&" = arg1 && arg2
--       | str == "neg"


evalBoolFunc :: (Ord a) => String -> a -> a -> Bool
evalBoolFunc str arg1 arg2
    | str == "==" = arg1 == arg2
    | str == "/=" = arg1 /= arg2
    | str == "<" = arg1 < arg2
    | str == ">" = arg1 > arg2
    | str == "<=" = arg1 <= arg2
    | str == ">=" = arg1 >= arg2


